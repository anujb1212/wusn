datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum SoilTexture {
  SANDY
  SANDY_LOAM
  LOAM
  CLAY_LOAM
  CLAY
}

enum Season {
  RABI
  KHARIF
  ZAID
  PERENNIAL
}

enum GrowthStage {
  INITIAL
  DEVELOPMENT
  MID_SEASON
  LATE_SEASON
  HARVEST_READY
}

model Node {
  id           Int      @id @default(autoincrement())
  nodeId       Int      @unique
  location     String?
  burialDepth  Int?
  distanceToGW Float?
  installDate  DateTime @default(now())
  lastSeen     DateTime @default(now())
  isActive     Boolean  @default(true)

  readings SensorReading[]

  // Field config for this node (one-to-one)
  field Field?

  @@index([nodeId])
}

model SensorReading {
  id     Int @id @default(autoincrement())
  nodeId Int

  // Raw soil sensor values (from buried sensor node)
  moisture    Int // Raw SMU value (0-1023)
  temperature Int // Raw soil temperature value

  // Calibrated soil measurements
  soilMoistureVWC Float // Volumetric Water Content (%)
  soilTemperature Float // Soil temperature (°C)

  // Air measurements from gateway (BME280 or similar)
  airTemperature Float // Air temperature (°C) - CRITICAL for GDD and ET calculations
  airHumidity    Float // Relative humidity (%)
  airPressure    Float? // Barometric pressure (hPa) - optional

  // Metadata
  timestamp DateTime @default(now())

  // Relations
  node     Node      @relation(fields: [nodeId], references: [nodeId])
  analysis Analysis?

  @@index([nodeId, timestamp])
  @@index([timestamp])
}

// DEPRECATED: Use SensorReading.airTemperature instead
model WeatherReading {
  id        Int    @id @default(autoincrement())
  gatewayId String

  airTemperature Float
  humidity       Float
  pressure       Float?

  timestamp DateTime @default(now())

  @@index([gatewayId, timestamp])
  @@index([timestamp])
}

model WeatherForecast {
  id        Int   @id @default(autoincrement())
  latitude  Float
  longitude Float

  forecastData Json // Array of daily forecasts: {date, tempMax, tempMin, precipitation, etc.}

  fetchedAt DateTime @default(now())
  expiresAt DateTime

  @@index([latitude, longitude, expiresAt])
}

model AggregatedReading {
  id              Int                 @id @default(autoincrement())
  timestamp       DateTime            @default(now())
  selectedNodeId  Int
  allNodesData    Json
  selectionScore  Float
  selectionReason String
  analysis        AggregatedAnalysis?

  @@index([timestamp])
  @@index([selectedNodeId])
}

model AggregatedAnalysis {
  id                  Int      @id @default(autoincrement())
  aggregatedReadingId Int      @unique
  timestamp           DateTime @default(now())
  fuzzyDryScore       Int
  fuzzyOptimalScore   Int
  fuzzyWetScore       Int
  soilStatus          String
  confidence          Int
  irrigationAdvice    String
  urgency             String

  aggregatedReading   AggregatedReading    @relation(fields: [aggregatedReadingId], references: [id])
  cropRecommendations CropRecommendation[]

  @@index([aggregatedReadingId])
}

model Analysis {
  id                Int      @id @default(autoincrement())
  readingId         Int      @unique
  timestamp         DateTime @default(now())
  fuzzyDryScore     Int
  fuzzyOptimalScore Int
  fuzzyWetScore     Int
  soilStatus        String
  confidence        Int
  irrigationAdvice  String
  urgency           String

  reading             SensorReading        @relation(fields: [readingId], references: [id])
  cropRecommendations CropRecommendation[]

  @@index([readingId])
  @@index([timestamp])
}

model CropRecommendation {
  id                   Int    @id @default(autoincrement())
  analysisId           Int?
  aggregatedAnalysisId Int?
  cropName             String
  suitability          Int
  reason               String
  rank                 Int

  analysis           Analysis?           @relation(fields: [analysisId], references: [id])
  aggregatedAnalysis AggregatedAnalysis? @relation(fields: [aggregatedAnalysisId], references: [id])

  @@index([analysisId])
  @@index([aggregatedAnalysisId])
  @@index([cropName])
}

//
// Field configuration
//

model Field {
  id        Int    @id @default(autoincrement())
  nodeId    Int    @unique // One field per sensor node
  gatewayId String // Gateway identifier for this field's sensor

  fieldName String
  location  String?
  latitude  Float
  longitude Float

  // ✅ Soil properties (restricted)
  soilTexture SoilTexture @default(SANDY_LOAM)

  // Crop information (null until crop confirmed by farmer)
  cropType            String? // references CropParameters.cropName when set
  sowingDate          DateTime?
  expectedHarvestDate DateTime?
  cropConfirmed       Boolean   @default(false)

  // ✅ Relations (integrity)
  node Node @relation(fields: [nodeId], references: [nodeId], onDelete: Cascade)

  // Ensure cropType (if set) must exist in CropParameters
  crop CropParameters? @relation(fields: [cropType], references: [cropName], onDelete: SetNull)

  // GDD tracking (runtime state - updated by GDD service using AIR temperature)
  accumulatedGDD     Float        @default(0)
  lastGDDUpdate      DateTime?
  currentGrowthStage GrowthStage?
  baseTemperature    Float?
  expectedGDDTotal   Float?

  // Irrigation tracking
  lastIrrigationCheck  DateTime?
  lastIrrigationAction DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  gddHistory GDDRecord[]

  @@index([nodeId])
  @@index([gatewayId])
  @@index([cropType])
  @@index([cropConfirmed, lastGDDUpdate])
  @@map("fields")
}

model GDDRecord {
  id      Int      @id @default(autoincrement())
  fieldId Int
  date    DateTime @db.Date

  // Daily AIR temperature data (from SensorReading.airTemperature aggregated daily)
  avgAirTemp    Float
  minAirTemp    Float?
  maxAirTemp    Float?
  readingsCount Int

  // GDD calculations: dailyGDD = max(0, (maxAirTemp + minAirTemp)/2 - baseTemperature)
  dailyGDD      Float
  cumulativeGDD Float

  // Crop context
  cropType        String?
  baseTemperature Float
  growthStage     GrowthStage?

  createdAt DateTime @default(now())

  field Field @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@unique([fieldId, date])
  @@index([fieldId])
  @@index([date])
  @@index([fieldId, date])
}

model Alert {
  id           Int      @id @default(autoincrement())
  nodeId       Int
  readingId    Int
  alertType    String
  message      String
  sentAt       DateTime @default(now())
  acknowledged Boolean  @default(false)

  @@index([nodeId, sentAt])
  @@index([acknowledged])
}

//
// Crop parameters reference data
// Seeded from seed.ts with 19 UP-valid crops (current universe)
//

model CropParameters {
  id       Int    @id @default(autoincrement())
  cropName String @unique

  // Temperature parameters
  soilTempMin     Float
  soilTempOptimal Float
  soilTempMax     Float

  // Soil moisture parameters (VWC %)
  vwcMin     Float
  vwcOptimal Float
  vwcMax     Float

  // GDD parameters (uses AIR temperature, not soil)
  baseTemperature Float
  totalGDD        Float

  // Irrigation parameters
  rootDepthCm Int
  mad         Float

  // Crop coefficient (Kc) for ET calculation - stored as JSON
  kc Json

  // Growth stage thresholds (in GDD, not days)
  initialStageGDD     Float
  developmentStageGDD Float
  midSeasonGDD        Float
  lateSeasonGDD       Float

  // Regional and seasonal metadata
  validForUP            Boolean       @default(true)
  season                Season
  soilTexturePreference SoilTexture[]

  // Back-reference to fields using this crop
  fields Field[]

  createdAt DateTime @default(now())

  @@map("CropParameters")
}

model IrrigationLog {
  id                   Int       @id @default(autoincrement())
  nodeId               Int
  timestamp            DateTime  @default(now())
  currentVWC           Float
  targetVWC            Float
  cropType             String?
  growthStage          String?
  shouldIrrigate       Boolean
  urgency              String
  reason               String
  estimatedWaterNeeded Float
  actionTaken          Boolean   @default(false)
  actionTimestamp      DateTime?
  actualWaterApplied   Float?

  @@index([nodeId, timestamp])
  @@index([shouldIrrigate])
}
